## Algoritmi Paraleli si Distribuiti - C++ - Map-Reduce

Codul definește câteva structuri cheie pentru organizarea datelor. WordOccurrence stochează un cuvânt și setul de ID-uri ale fișierelor în care apare acesta. Folosește un set<int> pentru eficiență la eliminarea duplicatelor. MapperOutput organizează cuvintele după prima lor literă pentru o procesare mai eficientă. SharedData menține datele ce trebuie partajate între toate thread-urile, inclusiv liste de fișiere și mecanisme de sincronizare. MapperData și ReducerData sunt structuri specializate ce conțin informațiile necesare pentru thread-urile mapper și reducer respectiv.

Programul începe prin citirea argumentelor care specifică numărul de thread-uri mapper și reducer dorite, precum și fișierul de input. Se inițializează apoi structurile necesare pentru sincronizare, se citește lista de fișiere de procesat, și se creează thread-urile. Programul așteaptă finalizarea tuturor thread-urilor înainte de a elibera resursele și a se încheia. Mapperii și reducerii sunt lansați folosind pthread_create, iar programul așteaptă ca toate thread-urile să termine folosind pthread_join.

Thread-urile mapper reprezintă prima fază a procesării. Acestea citesc fișierele disponibile de input în paralel (folosind un mutex pentru sicronizare), procesând textul pentru a extrage cuvintele. După extragere, cuvintele sunt grupate după prima lor literă, creând seturi intermediare de date. După ce un mapper termină, își salvează rezultatele într-o structură partajată (mapper_outputs), folosind un alt mutex (results_mutex). Mapperii așteaptă toți să termine folosind o barieră sincronizatoare. Astfel, conținutul fiecărui fișier este procesat pentru a identifica aparițiile fiecărui cuvânt, iar rezultatele sunt stocate într-un unordered_map. Această abordare permite procesarea simultană a mai multor fișiere, crescând semnificativ performanța pentru seturi mari de date.

Thread-urile reducer preiau rezultatele de la mapperi și le procesează în continuare. Fiecare reducer procesează un subset de litere (împărțite între thread-uri), identificând cuvintele care încep cu literele respective. Reducerii combină rezultatele de la mapperi și creează un unordered_map global pentru literele atribuite. Fiecare reducer sortează cuvintele și salvează rezultatele în fișiere separate (a.txt, b.txt, etc.).

Pentru manipularea eficientă a datelor, codul include mai multe funcții utilitare. Funcția get_file_size determină dimensiunea unui fișier pentru alocarea eficientă a memoriei. clean_word curăță cuvintele de caractere non-alfabetice și le convertesc la lowercase. process_text procesează textul dintr-un fișier și adaugă aparițiile fiecărui cuvânt într-un unordered_map. sort_and_write_entries sortează cuvintele după numărul de fișiere în care apar și după ordinea alfabetică, apoi scrie rezultatele într-un fișier.

Optimizare:

Se folosește reserve() pentru pre-alocarea vectorilor, reducând realocările de memorie. Seturile sunt utilizate pentru eliminarea eficientă a duplicatelor. Move semantics facilitează transferul eficient al datelor între componente. Divizarea muncii între thread-uri este realizată dinamic pentru a maximiza utilizarea resurselor disponibile. Fișierele sunt distribuite dinamic între mapperi, iar alfabetul este împărțit static între reduceri. Barierele și mutex-urile asigură consistența datelor în timpul procesării paralele.

Codul implementează o optimizare eficientă folosind o singură barieră (pthread_barrier_t) pentru sincronizarea între thread-urile mapper și reducer, în loc să folosească două bariere separate. Bariera este inițializată cu numărul total de thread-uri (mapperi + reduceri) și este folosită în două momente diferite: mapperii ajung la barieră după ce termină procesarea și așteaptă acolo, în timp ce reducerii încep prin a aștepta la aceeași barieră înainte de a-și începe procesarea. Acest mecanism asigură că reducerii nu încep să proceseze până când toți mapperii nu și-au terminat treaba și au populat structurile de date necesare, oferind astfel o sincronizare eficientă cu overhead minim și evitând necesitatea unor mecanisme de sincronizare adiționale.