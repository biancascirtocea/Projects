TASK 1
In cadrul pointerului, prin intermediul acelui for, vom citi pe rand, in functie de numarul de octeti ai fiecarei date salvate, informatiile despre avion. O sa manevram pointerul, precum un vector pentru adrese, din care vom citi adresa fiecarui tip de date, in functie de cat de mult spatiu au nevoie sa fie stocate. Astfel, prima oara vom citi numarul liniei capului avionului, salvat de tip short pe cei doi octeti, si trecem mai departe la urmatoarea adresa de memorie, care este tot de tip short pe 2 octeti. Dupa ce trece si peste asta, se citeste directia avionului care este stocata in memorie pe un octet, specific tipului de date char. Dupa, trecem in pointer la urmatoarea adresa, unde se vor citi 4 date de tip char, ce corespund codului avionului. Dupa ce citeste un octet pentru o variabila de tip char, trece la urmatoarele (aceasta miscare realizandu-se in cadrul forului). Dupa, ce iese din for codul avionului a fost citi. In final, se citeste un tip de date int, salvat pe 4 octeti, ce reprezinta viteza avionului. Aceste date se citesc pentru fiecare avion in parte si se salveaza in vectorii corespunzatori specificului lor. In cadrul, for-ului din final se afiseaza datele fiecarui avion pe rand, cu un rand spatiu intre fiecare avion.

Task 2
Dupa ce se citesc informatiile din pointer exact ca la taskul 1, vom parcurge printr-un vector informatiile legate de coloana, linia, tipul si directia fiecarui avion. Stim ca matricea este completata initial numai cu ".". Programul o sa puna, numai in locurile unde trebuie sa se afle avionul, "*". Acesta completeaza, in primul rand, capul avionului, dupa in functie de tipul avionului, iar pe urma in functie de directia acestuia realizeaza si corpul. Dupe ce capul este completat, programul mai are de realizat la avionul de tip 1 coada, aripile si corpul ce uneste aceste doua componente, in total 9 "*". La cel de tip 2, mai are de completat 15 "*", asociate cozii, aripilor, corpului ce le uneste pe cele doua si corpul ce uneste capul de aripi. In final, este afisata matricea avioanelor.

Task 3
Spre deosebire de celelalte task-uri, aici am salvat toate informatiile, prealuate din pointer ca la taskul 1, intr-o structura de date, pentru a putea ordona avioanele si toate informatiile lor dupa anumite criterii. Astfel, structura are eticheta inf_avioane. Functia comp reprezinta functia de comparare necesara lui qsort, unde in primele 2 if-uri se verifica in ce ordine ar trebuii puse avioanele, in functie de tipul acestora. Cel de - al treilea if utilizeaza functia predefinita strcmp ce compara un sir de caractere . Rezultatul acesteia este determinat de ordinea lexico-grafica, dar programul trebuie sa afiseze in mod invers lexico-grafic. Astfel, acest if returneaza inversul rezultatului lui strcmp (strcmp(...)*(-1)). Iar, in final se returneaza diferenta vitezelor, functia qsort ordonand in ordine crescatoate in functie de aceasta, ca un ultim criteriu. Dupa apelarea functiei qsort, se afiseaza datele avioanelor in functie de cerinta taskului.  

Task 4
Se citesc informatiile despre avion exact ca la taskul 1. Dupa, parcurgem informatiile despre linie, coloana, directie si tip pentru fiecare avion in parte pentru a vedea daca intampina sau nu pana la iesirea de pe harta obstacole. Variabila ok initial este 1 pentru fiecare avion in parte, daca dupa toate testele ea nu devine 0, inseamna ca avionul nu este blocat in drumul lui de niciun obstacol, astfel se numara avionul (variabila nr creste cu o unitate). Cum aripile avionului realizeaza cea mai extinsa dimensiune a acestuia pe latime, trebuie verificat daca ele se intalnesc in drum cu un obstacol. Iar, apoi se verifica daca in spatiul dintre aripi si coada ar fi vreun obstacol in drumul cozii avionului. In functie de tipul avionului si directia acestuia, se verifica pentru fiecare obstacol in parte, prin intermediul primului if, daca coordonatele obstacolului se afla undeva in drumul parcurs de aripile avionului. De exemplu, pentru tipul 1, directia N, daca linia obstacolului este mai mica sau egala cu linia pe care se afla aripile avionului, atunci programul verifica daca acest obstacol se afla si intre limitele determinate de lungimea aripilor (comparand coloana obstacolului cu coloanele intre care se desfasoara aripile) . Astfel, daca ambele if-uri sunt adevarate ok devine 0, deci exista un obstacol in drumul avionului. Dupa, programul testeaza daca in spatiul dintre coada si aripile avionului se afla un obstacol, de data aceasta nu intre limitele impuse de lungimea aripilor avionului, ci de lungimea cozii, deoarece avionul merge mereu inainte, nu o ia inapoi. Astfel, acest rationament este utilizata pentru fiecare tip si directie in parte. Programul verfica daca se afla un obstacol si in componenta aripilor, deoarece pentru testul 3, inputul celui de-al doilea avion pune un obstacol pe aripa avionului. In final, se afiseaza numarul de avioane care nu au intampinat in calea lor niciun obstacol, adica cele care au avut ok = 1, dupa toate acele if-uri.

Task 5
Se citesc informatiile din pointer exact ca la taskul 1. Dupa, pentru fiecare timp, se ia o variabila nr, care va numara avioanele care sunt lovite de obstacole. Astfel, se ia fiecare avion in parte , iar in cadrul forului se salveaza informatiile legate de coloana, linia, directia si tipul avionului. Variabila ok , initial este 0, iar ea devine 1 in momentul in care un obstacol este gasit in corpul avionului. Variabila mom reprezinta momentul in care se afla avionul, anume spatiul in care se afla, adica daca avionul a inaintat si cu cat a inaintat. Astfel, pentru fiecare tip de avion si pentru fiecare directie , se verifica printr-un for daca vreunul dintre obstacole se afla pozitionat in corpul avionului. If-urile verifica daca coordonatele obstacolului se afla in corpul avionului, in mom respectiv. De exemplu, pentru avionul de tip 1, directia N, primul if verifica daca exista un obstacol in locul capului aionului in mom dat, cel de-al doilea if verifica corpul ce uneste aripile de coada, cel de-al treilea verifica aripile, iar ultimul if coada avionului. Daca vreun if este adevarat, atunci ok devine 1, iar dupa toate acele if-uri, daca ok este 1 se numara. Dupa ce au fost testate toate avioanele se afiseaza la timpul T cate avioane au fost lovite de obstacole. 

